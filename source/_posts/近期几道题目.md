---
title: 近期的几道题目
date: 2023-04-02 18:12
category: 题目

---

# 感想

好久没做题了，思维和实现能力很明显的下滑，最大的问题是不太会思考了，需要多做一些防止痴呆。

# EOJ 图森未来杯

比赛地址：[EOJ](https://acm.ecnu.edu.cn/contest/621/)

I. 宝箱
有n个红宝箱和n个蓝宝箱，需要在每个宝箱中放不同正整数的金币，且同颜色宝箱 a[i] > a[i-1]，求宝箱最大金币数的最小值

这道题目尝试DP未解出，是因为下意识将同一位置捆绑了，感觉有若干限制很难找到最优子问题。但DP的本质是什么呢？按自己现在的理解是在解空间寻求最优解向量？这样说不知道对不对。需要在理解层面加深。

所以这道题可以用 dp[i][j] 表示红 i 蓝 j 后最大金币最小化的值，因此下一个要放的值是 dp[i][j] + 1（若奇偶性满足），否则 dp[i][j] + 2，然后更新状态。

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;
int a[1020], b[1020];
int dp[1020][1020];
int main() {
    int n;
    cin>>n;
    for(int i=1;i<=n;i++) {
        cin>>a[i];
    }
    for(int i=1;i<=n;i++) {
        cin>>b[i];
    }
    for(int i=0;i<=n;i++) {
        for(int j=0;j<=n;j++) {
            dp[i][j]=1e9;
        }
    }
    dp[0][0]=0;
    for(int i=0;i<=n;i++) {
        for(int j=0;j<=n;j++) {
            int v=dp[i][j]+1;
            if(i<n) {
                if((a[i+1]+v)%2==0)
                    dp[i+1][j]=min(dp[i+1][j], dp[i][j]+1);
                else 
                    dp[i+1][j]=min(dp[i+1][j], dp[i][j]+2);
            }
            if(j<n) {
                if((b[j+1]+v)%2==0) 
                    dp[i][j+1]=min(dp[i][j+1], dp[i][j]+1);
                else 
                    dp[i][j+1]=min(dp[i][j+1], dp[i][j]+2);
            }
        }
    }
    cout<<dp[n][n]<<"\n";
}

```



# 力扣周赛+双周赛

6365. 最少翻转操作数 [URL](https://leetcode.cn/problems/minimum-reverse-operations/)

数组 a[]，位置 p 值为1，否则为0。限制是某些位置要求不能为1。现在给定长度 k，问对于每个位置，求执行最少次数翻转长度为 k 子数组使得该位置为 1。

通过画图可得下标为 i 的 1 翻转区间为 $[i-(k-1), i+(k-1)]$ 的公差为 2 的等差数列，对于越界的情况无法翻转，因此要处理边界情况，因此：左区间  $max(k-i-1, i-(k-1))$，右区间 $min(2*n-k-i-1,i+(k-1))$

对于最小次数，考虑BFS。因为从数据看直接枚举区间的复杂度 $O(nk)$ 无法接受，考虑 set 维护备选下标，针对公差为 2 的情况使用两个 set 分别维护，不断删除。

代码是学习别人的

1. 通过枚举 steps 的方式维护次数，而不是 queue<pair<index, cost>> & while(que.size())
2. 枚举 set 可以 t = s.erase(t)
3. vector<> 维护队列 + move
4. move方法，将左值强制转化为右值引用，用于移动语义。无内存拷贝等操作，转移对象的状态或所有权？所以这样效率比每次 push_back 要高

```c++
class Solution {
public:
    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {
        set<int> s[2];
        unordered_set<int> ban{banned.begin(), banned.end()};
        for(int i=0;i<n;i++) {
            if(i!=p&&!ban.count(i)) {
                s[i&1].insert(i);
            }
        }
        s[0].insert(n);
        s[1].insert(n);

        vector<int> ans(n, -1);
        vector<int> que{p};
        for(int steps=0; que.size(); steps++) {
            vector<int> tmp;
            for(int i: que) {
                ans[i]=steps;
                int mn=max(k-i-1,i-k+1);
                int mx=min(2*n-k-i-1,i+k-1);
                set<int>& ss=s[mn&1];
                for(auto it=ss.lower_bound(mn); *it<=mx; it=ss.erase(it)) {
                    tmp.push_back(*it);
                }
            }
            que = move(tmp);
        }
        return ans;
    }
};
```



6329. 使子数组元素和相等 [URL](https://leetcode.cn/problems/make-k-subarray-sums-equal/)

循环数组 arr，求最小修改某个元素+1或-1的次数，使得任意长度为 k 的子数组元素总和相等

可以根据长度为 k 的窗口推移得知 $a[i]=a[i+k]=a[i+2*k]=...$ 循环周期为 k

另外对于循环数组，因此天然周期为 n (数组长度)

刚得知循环数组既有周期 n 又有周期 k，因此必然有周期 $gcd(n,k)$ 即 $a[i]=a[i+nx+ky]=a[i+gcd(n,k)]$ 

因此按周期分区间，然后使得同类数字最小次数相同，即取中位数

学到了：

1. 两个周期可以 gcd，那三个周期？TODO
2. nth_element() 方法

```c++
class Solution {
public:
    long long makeSubKSumEqual(vector<int> &arr, int k) {
        int n = arr.size();
        k = gcd(k, n);
        vector<vector<int>> g(k);
        for (int i = 0; i < n; ++i)
            g[i % k].push_back(arr[i]);

        long long ans = 0;
        for (auto &b: g) {
            nth_element(b.begin(), b.begin() + b.size() / 2, b.end());
            for (int x: b)
                ans += abs(x - b[b.size() / 2]);
        }
        return ans;
    }
};
```


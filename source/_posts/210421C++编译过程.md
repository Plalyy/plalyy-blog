---
title: C/C++编译过程
date: 2021-04-21 00:12
category: 技术
---

本科毕设需要C++项目，顺便重温下C++编译过程

<!--more-->

## C/C++编译过程

C/C++文件->可执行文件：预处理、编译、汇编、链接

预处理（-E）：主要处理include、define等，插入头文件、替换定义宏

编译（-S）：生成汇编文件。

汇编（-c）：翻译成二进制机器指令文件

链接（-o）：链接函数库

## C++静态库和动态库

库的本质是二进制可执行文件，函数库一般分为静态库(.a、.lib)和动态库(.so、.dll)

- 静态库在编译时被载入。静态链接将汇编生成的.o目标文件和库一起链接打包到可执行文件。一个静态库可以简单看作目标文件(.o/.obj)的集合。
  - 特点：移植方便（运行时和函数库无关）、浪费空间和资源（被多次使用则需要在内存里有多份拷贝）、全量更新（某静态库更新会导致所有包含它的文件重新编译、发布）。
  - 命名规则：lib[lib_name].a，lib为前缀
- 动态库在运行时被载入。不同程序调用相同的库时，内存中只需要一份实例共享，解决空间浪费问题。更新时也避免全量更新问题，做到增量更新
  - 特点：实现进程之间资源共享（动态库又称资源库）、使一些程序升级简单、可以做到链接载入由程序代码中控制（**显示调用**）。
  - 命名规则：lib[lib_name].so，lib为前缀。
    - 针对实际库文件，每个共享库有个特殊名字soname。程序启动后，程序通过这个名字告诉动态加载器载入哪个共享库。
    - 文件系统中，soname仅是链接到实际动态库的链接。动态库实际有另一个名字给编译器使用。它是一个指向实际库镜像文件的链接文件（lib[soname].so）。
  - **动态库的显示调用**
    - C语言中很容易调用，Linux下dlfcn.h提供了接口，Windows则需要LoadLibrary、GetProcAddress、FreeLibrary等。
    - C++复杂，一是C++的[name mangling](https://zh.wikipedia.org/wiki/%E5%90%8D%E5%AD%97%E4%BF%AE%E9%A5%B0)，二是没有合适的API来加载类。C++中可能用到库中的类，但需要创建类的实例，不容易。name mangling通过extern "C"解决，从动态库中获取类（不建议）见参考文章[2]、[3]。
    - 使用C++动态库中的class非常繁琐和危险，因此能隐式不显式，能静态不动态。
- 二者不同点在于代码被载入的时刻不同，动态库因为[DLL Hell](https://zh.wikipedia.org/wiki/DLL%E5%9C%B0%E7%8D%84) 问题要注意动态库管理问题。Java中在不经过封装的情况下只能直接使用动态库。

## Linux库相关命令

### nm命令：查看库中包含函数

**nm**命令可以打印出库中的涉及到的所有符号。库既可以是静态的也可以是动态的。nm列出的符号有很多，常见的有三种：

- 一种是在库中被调用，但并没有在库中定义(表明需要其他库支持)，用U表示；

- 一种是库中定义的函数，用T表示，这是最常见的；

- 一种是所谓的弱态”符号，它们虽然在库中被定义，但是可能被其他库中的同名符号覆盖，用W表示。

### ldd命令：查看可执行程序依赖的共享库



## 参考文章：

[1] C++静态库与动态库：https://www.cnblogs.com/skynet/p/3372855.html

[2] LoadLibrary调用DLL中的Class：http://www.cppblog.com/codejie/archive/2009/09/24/97141.html

[3] C++ dlopen mini HOWTO：http://blog.csdn.net/denny_233/article/details/7255673